#!/bin/sh /etc/rc.common
USE_PROCD=1
START=45
PORT=33123

DAEMON=/usr/sbin/babeld
pidfile=/var/run/gluon-babeld.pid
CONFIGFILE=/etc/gluon-babeld.conf

start_service() {
	procd_open_instance
	procd_set_param command $DAEMON
	procd_append_param command -D -I "$pidfile" -G "$PORT" -c "$CONFIGFILE" lo
	procd_set_param respawn ${respawn_threshold:-60} ${respawn_timeout:-5} ${respawn_retry:-0}
	procd_set_param stderr 1
	procd_set_param stdout 1
	procd_close_instance
}

echotobabel() {
	local count=0
	local line="$1"
	while ! (echo -e "$line" | nc ::1 "$PORT" >/dev/null 2>&1)
	do
		sleep 1
		echo retrying to connect to babeld in PID $$, waited ${count}s >&2
		count=$((count+1))
	done
}

waitforsocket() {
	retval=99
	echotobabel "dump"
	[ $retval -gt 0 ] && (echo "Failed to connect to babeld socket on port $PORT, assuming the service was not started properly"; exit 43) 
}

reload_service() {
	status=$(ifstatus "$PARAM_interface")
	if echo "$status" |jsonfilter -e "@.proto"|grep -q "gluon_mesh"
	then
		waitforsocket
		if echo "$status" |jsonfilter -e "@.up"|grep -q "true"
		then
			echotobabel "interface $PARAM_device"
		else
			echotobabel "flush interface $PARAM_device"
		fi
	fi
}

service_triggers() {
	local script=$(readlink "$initscript")
	local name=$(basename "${script:-$initscript}")

	procd_open_trigger
	procd_add_raw_trigger "interface.*" 0 "/etc/init.d/$name" reload
	procd_close_trigger
}

service_started() {
	# make sure the init script does not finish until babeld is actually up.
	# unfortunately procd will still start multiple instances of the same script which is why waitforsocket is also run on reload
	waitforsocket
}
